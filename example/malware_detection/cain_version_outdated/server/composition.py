from ray import serve
import json, os
import numpy as np
import os, time, uuid, ray
from qoa4ml.reports import Qoa_Client
import qoa4ml.utils as qoa_utils
import aggregation
import pymongo
import pandas as pd
from utils import get_hash_vec
from scipy.sparse import csr_matrix
from detector import Malware_Detector


def init_env_variables():
    # Get Pod ID: for monitoring
    pod_id = os.environ.get("POD_ID")
    if not pod_id:
        print("POD_ID is not defined")
        pod_id = "Empty"
    # Get Node name: for monitoring
    node_name = os.environ.get("NODE_NAME")
    if not node_name:
        print("NODE_NAME is not defined")
        node_name = "Empty"
    # Get Database Url
    database_url = os.environ.get("DATABASE_URL")
    if not database_url:
        print("DATABASE_URL is not defined")
        database_url = "mongodb://localhost:27017/"
    # Get Database name
    database_name = os.environ.get("DATABASE_NAME")
    if not database_name:
        print("DATABASE_NAME is not defined")
        database_name = "malware_detection_db"
    # Get user collection name
    user_collection_name = os.environ.get("USER_COLLECTION")
    if not user_collection_name:
        print("USER_COLLECTION is not defined")
        user_collection_name = "user_data"
    # Get Customer id
    customer_id = os.environ.get("CUSTOMER_ID")
    if not customer_id:
        print("CUSTOMER_ID is not defined")
        customer_id = "Aaltosea40"

    return {
        "pod_id": pod_id,
        "node_name": node_name,
        "database_url": database_url,
        "database_name": database_name,
        "user_collection_name": user_collection_name,
        "customer_id": customer_id,
    }


env_var = init_env_variables()

database_name = env_var["database_name"]
u_col_name = env_var["user_collection_name"]

mongo_client = pymongo.MongoClient(env_var["database_url"])


dblist = mongo_client.list_database_names()
if database_name not in dblist:
    print("The database {} not exists.".format(database_name))
database_mg = mongo_client[database_name]

collist = database_mg.list_collection_names()
if u_col_name in collist:
    print("The collection {} not exists.".format(u_col_name))
user_collection = database_mg[u_col_name]

last_updated_u_data = None
while True:
    u_query = {"id": env_var["customer_id"]}
    customer_data = user_collection.find(u_query).sort(
        [("timestamp", pymongo.DESCENDING)]
    )
    try:
        print(customer_data)
        object_iterator = iter(customer_data)
        last_updated_u_data = object_iterator[0]
        break
    except TypeError as te:
        print(customer_data, " is not iterable")
        time.sleep(10)
print("Downloading customer data success: ", last_updated_u_data)

client_config = last_updated_u_data["client_config"]
connector_conf = last_updated_u_data["connector_conf"]
stage_conf = last_updated_u_data["ensemble_model"]


@ray.remote
def data_processing(data, user_data):
    dp_qoa = Qoa_Client(client_config, connector_conf)
    #####
    dp_conf = stage_conf["data_processing"][0]
    dp_qoa.init_report(dp_conf["instance_id"], dp_conf["method"], dp_conf["stage_id"])
    dp_qoa.timer()

    df_test = pd.DataFrame(data, index=[0])
    if user_data["vector"] == "apiargs":
        hash_vec = get_hash_vec(user_data["method"])
        x_test = hash_vec.transform(df_test["abstracted_api_info"])
    if user_data["vector"] == "ember":
        x_test = (
            df_test["features"].str.split(",", expand=True).to_numpy(dtype="float32")
        )
        x_test = csr_matrix(x_test)

    print(user_data)

    responsetime = dp_qoa.timer()
    report = dp_qoa.report_external(responsetime)
    return x_test, report


@ray.remote
def max_aggregate(predictions, report_list=[]):
    m_agg_qoa = Qoa_Client(client_config, connector_conf)
    ###
    m_agg_conf = stage_conf["aggregation"][0]
    m_agg_qoa.init_report(
        m_agg_conf["instance_id"], m_agg_conf["method"], m_agg_conf["stage_id"]
    )
    m_agg_qoa.timer()
    for report in report_list:
        m_agg_qoa.get_reports(report)

    agg_prediction = aggregation.agg_max(predictions)

    result = m_agg_qoa.ex_observe_confidence(
        agg_prediction[0], agg_prediction[1], predictions
    )
    responsetime = m_agg_qoa.timer()
    report = m_agg_qoa.report_external(responsetime, submit=True)
    return result, report


@serve.deployment
class Detector:
    def __init__(self, param):
        apiargs_param = param.copy()
        ember_param = param.copy()
        apiargs_param["model_name"] = "apiargs_" + apiargs_param["model_name"]
        ember_param["model_name"] = "ember_" + ember_param["model_name"]
        self.apiargs_model = Malware_Detector(apiargs_param)
        self.ember_model = Malware_Detector(ember_param)
        self.qoa = Qoa_Client(client_config, connector_conf)
        ######
        self.qoa.init_report(param["instance_id"], param["method"], param["stage_id"])
        self.qoa.proc_monitor_flag = True
        self.qoa.process_monitor(5)

    def predict(self, x_test, user_data, report_list=[]):
        self.qoa.timer()
        for report in report_list:
            self.qoa.get_reports(report)
        if user_data["vector"] == "apiargs":
            y_pred, y_prob = self.apiargs_model.predict(x_test)
        if user_data["vector"] == "ember":
            y_pred, y_prob = self.ember_model.predict(x_test)
        prediction = self.qoa.ex_observe_confidence(y_pred, y_prob)
        responsetime = self.qoa.timer()
        report = self.qoa.report_external(responsetime)
        return prediction, report


@serve.deployment
class Ensemble_ML:
    def __init__(self, model_list):
        self.models = model_list

    async def __call__(self, http_request):
        files = await http_request.form()
        b_data = await files["data"].read()
        b_user_data = await files["user_data"].read()
        data = json.loads(b_data)
        user_data = json.loads(b_user_data)

        x_test, dp_report = await data_processing.remote(data, user_data)
        predictions = []
        report_list = []
        for model in self.models:
            result = await model.predict.remote(x_test, user_data, [dp_report])
            predition, report = ray.get(result)
            predictions.append(predition)
            report_list.append(report)
        agg_pred, agg_report = await max_aggregate.remote(predictions, report_list)
        return agg_pred


if last_updated_u_data != None:
    instacnes = stage_conf["ml_inference"]
    try:
        model_list = []
        for instance in instacnes:
            model = Detector.bind(instance)
            print("Adding instance: ", instance)
            model_list.append(model)
    except Exception as e:
        print("[Error]: {}".format(e))
    ensemble = Ensemble_ML.bind(model_list)

    serve.run(ensemble, host="0.0.0.0", port="8111")
